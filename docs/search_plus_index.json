{"./":{"url":"./","title":"序言","keywords":"","body":"序言序言 我仍然清晰地记得那个日子，我发布了这个开源项目第一个版本并在 IRC 聊天室创建一个频道，在那个最紧张的时刻，独自一人，急切地希望和盼望着第一个用户的到来。 第一个跳进 IRC 频道的用户就是 Clint（克林顿），当时我好兴奋。好吧… 过了一会直到我发现 Clint 实际上是 Perl 用户啦，还是跟死亡讣告网站打交道。 我记得（当时）问自己为什么他不是来自于更“主流”的社区，像 Ruby 或 Python，亦或是一个稍微好点的使用案例。 我真是大错特错！Clint 最终对 Elasticsearch 的成功起到了重要作用。他是第一个把 Elasticsearch 扔到生产环境中的人（还是 0.4 的版本！），初期与 Clint 的互动对于塑造 Elasticsearch 成今天的样子非常关键。对于什么是简单，Clint 有独特的见解并且他很少出错，这对 Elasticsearch 从管理、API 设计和日常使用等各个方面的易用性上面产生了很大的影响。 所以我们公司成立后不久，我们想也没想立即就联系 Clint 问他是否愿意加入我们。 当我们成立公司时，我们做的第一件事就是提供公开培训。很难表达我们当时有多么紧张和担心是否真的有人会报名。 但我们错了。 培训到现在依然很成功，很多主要城市都还有大量的人等待参加。参加培训的人之中，有一个年轻的家伙吸引了我们注意，他的名字叫 Zach。 我们知道他有很多关于 Elasticsearch 的博客（并暗自嫉妒他用非常简单的方式来阐述复杂概念的能力），他还编写了一个 PHP 的客户端。 然后我们发现 Zach 他还是自掏腰包来参加我们的培训！你真的不能要求更多，于是我们找到 Zach，问他是否愿意加入我们的公司。 Clint 和 Zach 是 Elasticsearch 能否成功的关键。他们是完美的解说家，从简单的上层应用到复杂的（Apache Lucene 的）底层逻辑。在 Elastic 这里我们非常珍惜这种独特技能。 Clint 还负责 Elasticsearch Perl 客户端，而 Zach 则负责 PHP，都是精彩的代码。 最后，两位在 Elasticsearch 项目每天都在发生的大多数事情中也扮演着重要的角色。Elasticsearch 如此受欢迎的主要原因之一就是拥有与用户沟通产生共鸣的能力，Clint 和 Zach 都是这个集体的一份子，这让一切成为可能。 Shay Banon Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-22 13:12:46 "},"1Preface.html":{"url":"1Preface.html","title":"前言","keywords":"","body":"前言谁应该读这本书为什么我们要写这本书Elasticsearch版本 如何读这本书本书导航在线资源本书协议约定使用代码示例鸣谢前言 这个世界已然被数据淹没。多年来，我们系统间流转和产生的大量数据已让我们不知所措。 现有的技术都集中在如何解决数据仓库存储以及如何结构化这些数据。 这些看上去都挺美好，直到你实际需要基于这些数据实时做决策分析的时候才发现根本不是那么一回事。 Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，这是通常没有预料到的。 它存在还因为原始数据如果只是躺在磁盘里面根本就毫无用处。 无论你是需要全文搜索，还是结构化数据的实时统计，或者两者结合，这本指南都能帮助你了解其中最基本的概念， 从最基本的操作开始学习 Elasticsearch。之后，我们还会逐渐开始探索更加高级的搜索技术，不断提升搜索体验来满足你的用户需求。 Elasticsearch 不仅仅只是全文搜索，我们还将介绍结构化搜索、数据分析、复杂的语言处理、地理位置和对象间关联关系等。 我们还将探讨如何给数据建模来充分利用 Elasticsearch 的水平伸缩性，以及在生产环境中如何配置和监视你的集群。 谁应该读这本书 这本书是写给任何想要把他们的数据拿来干活做点事情的人。不管你是新起一项目从头开始还是为了给遗留系统改造换血， Elasticsearch 都能够帮助你解决现有问题和开发新的功能，有些可能是你之前没有想到的功能。 这本书既适合初学者也适合有经验的用户。我们希望你有一定的编程基础，虽然不是必须的，但有用过 SQL 和关系数据库会更佳。 我们会从原理解释和基本概念出发，帮助新手在复杂的搜索世界里获得一个稳定的基础。 具有搜索背景的读者也会受益于这本书。有经验的用户将懂得其所熟悉搜索的概念在 Elasticsearch 是如何对应和具体实现的。 即使是高级用户，前面几个章节所包含的信息也是非常有用的。 最后，也许你是一名 DevOps，其他部门一直尽可能快的往 Elasticsearch 里面灌数据，而你是那个负责阻止 Elasticsearch 服务器起火的消防员。 只要用户在规则内行事，Elasticsearch 集群扩容相当轻松。不过你需要知道如何在进入生产环境前搭建一个稳定的集群，还能要在凌晨三点钟能识别出警告信号，以防止灾难发生。 前面几章你可能不太感兴趣，但这本书的最后一部分是非常重要的，包含所有你需要知道的用以避免系统崩溃的知识。 为什么我们要写这本书 我们写这本书，因为 Elasticsearch 需要更好的阐述。 现有的参考文档是优秀的 — 前提是你知道你在寻找什么。它假定你已经熟悉信息检索的概念、分布式系统原理、Query DSL 和许多其他相关的概念。 这本书没有这样的假设。它的目的是写一本即便是一个完全不懂的初学者（不管是搜索还是分布式系统）也能拿起它简单看完几章，就能开始搭建一个原型。 我们采取一种基于问题求解的方式：这是一个问题，我该怎么解决？ 如何对候选方案进行权衡取舍？我们从基础知识开始，循序渐进，每一章都建立在前一章之上，同时提供必要的实用案例和理论解释。 现有的参考文档解决了 如何 使用这些功能，我们希望这本书解决的是 为什么 和 什么时候 使用这些功能。 Elasticsearch版本 本书的初始印刷版针对的是 Elasticsearch 1.4.0，不过我们一直在不断更新内容和完善示例 本书的线上版本 针对的是 Elasticsearch 2.x。 你可以访问这本书的 GitHub 仓库 来追踪最新变化。 如何读这本书 Elasticsearch 做了很多努力和尝试来让复杂的事情变得简单，很大程度上来说 Elasticsearch 的成功来源于此。 换句话说，搜索以及分布式系统是非常复杂的，不过迟早你也需要掌握一些来充分利用 Elasticsearch。 恩，是有点复杂，但不是魔法。我们倾向于认为复杂系统如同神奇的黑盒子，能响应外部的咒语，但是通常里面的工作逻辑很简单。 理解了这些逻辑过程你就能驱散魔法，理解内在能够让你更加明确和清晰，而不是寄托于黑盒子做你想要做的。 这本权威指南不仅帮助你学习 Elasticsearch，而且带你接触更深入、更有趣的话题，如 集群内的原理 、 分布式文档存储 、 执行分布式检索 和 分片内部原理 ，这些虽然不是必要的阅读却能让你深入理解其内在机制。 本书的第一部分应该是在按章节顺序阅读，因为每一章建立在上一章的基础上（尽管你也可以浏览刚才提到的章节）。 后续各章节如 近似匹配 和 部分匹配 相对独立，你可以根据需要选择性参阅。 本书导航 这本书分为七个部分： 章节 你知道的, 为了搜索… 到 分片内部原理 主要是介绍 Elasticsearch。介绍了 Elasticsearch 的数据输入输出以及 Elasticsearch 如何处理你的文档数据。 如何进行基本的搜索操作和管理你的索引。 本章结束你将学会如何将 Elasticsearch 与你的应用程序集成。 章节：集群内的原理、分布式文档存储、 执行分布式检索 和 分片内部原理 为附加章节，目的是让你了解分布式处理的过程，不是必读的。 章节 结构化搜索 到 控制相关度 让你深入了解搜索，如何索引和查询你的数据，并借助一些更高级的特性，如邻近词（word proximity）和部分匹配（partial matching）。你将了解相关度评分是如何工作的以及如何控制它来确保第一页总是返回最佳的搜索结果。 章节 开始处理各种语言 到 拼写错误 解决如何有效使用分析器和查询来处理语言的头痛问题。我们会从一个简单的语言分析下手，然后逐步深入，如字母表和排序，还会涉及到词干提取、停用词、同义词和模糊匹配。 章节 高阶概念 到 Doc Values and Fielddata 讨论聚合（aggregations）和分析，对你的数据进行摘要化和分组来呈现总体趋势。 章节 地理坐标点 到 地理形状 介绍 Elasticsearch 支持的两种地理位置检索方式：经纬坐标点和复杂的地理形状（geo-shapes）。 章节 关联关系处理 到 扩容设计 谈到了如何为你的数据建模来高效使用 Elasticsearch。在搜索引擎里表达实体间的关系可能不是那么容易，因为它不是用来设计做这个的。这些章节还会阐述如何设计索引来匹配你系统中的数据流。 最后，章节 监控 到 部署后 将讨论生产环境上线的重要配置、监控点以及如何诊断以避免出现问题。 在线资源 因为本书侧重如何在 Elasticsearch 里解决实际问题，而不是语法介绍，所以有时候你需要访问 Elasticsearch 参考手册 来获取详细说明。 你可以访问以下网址获取最新的 Elasticsearch 参考手册和相关文档： https://www.elastic.co/guide/ 如果你遇到本书或者参考手册没有收录到的问题，我们建议你访问 Elasticsearch 讨论社区来提问，学习别人是如何使用 Elasticsearch 的或者分享你自己的经验： 英文社区 中文社区 本书协议约定 以下是本书中使用的印刷规范： 斜体 表示重点、新的术语或概念。 等宽字体 用于程序列表以及在段落中引用变量或程序元素如：函数名称、数据库、数据类型、环境变量、语句和关键字。 这个图标代表小贴士，建议。 这个图标代表一般注意事项。 这个图标代表警告。 使用代码示例 本书的目的是为了帮你尽快能完成工作。一般来说，本书提供的示例代码你都可以用于你的程序或文档。 你不需要联系我们来询问许可，除非你打算复用相当大一部分代码。比如，写一个程序用了一段本书的代码不需要许可，但是销售或者是发行一张包含所有 O’Reilly 图书的示例代码的 CD 这个就需要许可。 引用这本书、引用示例代码来回答问题不需要许可，将大量的示例代码从这本书中包含到您的产品的文档中，这个需要许可。 关于署名出处，我们欣赏但不是必须。一个出处通常包含：书名、作者、出版商和 ISBN。如： Elasticsearch: The Definitive Guide by Clinton Gormley and Zachary Tong (O’Reilly). Copyright 2015 Elasticsearch BV, 978-1-449-35854-9。 如果你觉得你的示例代码使用超出合理使用或上面给出的许可，可随时与我们联系permissions@oreilly.com。 鸣谢 为什么配偶总是被放到最后一个？但并非是说最不重要！ 在我们心中毫无疑问，有两个最值得我们感谢的人，他们是 Clinton 长期受苦的老婆和 Zach 的未婚妻。 他们照顾着我们和爱着我们，毫不懈怠，忍受我们的缺席和我们没完没了的抱怨这本书还要多久完成，最重要的是，她们依然还在我们身边。 感谢 Shay Banon 在最开始创建了 Elasticsearch，感谢 Elastic 公司支持本书的工作。 也非常感谢 Elastic 所有的同事，他们帮助我们透彻的了解 Elasticsearch 内部如何工作并且一直负责添加完善和修复与他们相关的部分。 其中两位同事特别值得一提： Robert Muir 耐心地分享了他的真知灼见，特别是 Lucene 搜索方面。有几章段落就是直接出自其智慧珠玑。 Adrien Grand 深入到代码中回答问题，并检查我们的解释，以确保他们合理。 感谢 O’Reilly 承担这个项目和我们一起工作使这本书免费在线阅读，还有一直温柔哄骗我们的编辑 Brian Anderson 和善良而温柔的评论者 Benjamin Devèze、Ivan Brusic 和 Leo Lapworth。你们的鼓励，让我们充满希望。 感谢我们的读者，其中一些我们只有通过各自的 GitHub 才知道他们的身份，他们花时间报告问题、提供修正或提出改进建议： Adam Canady, Adam Gray, Alexander Kahn, Alexander Reelsen, Alaattin Kahramanlar, Ambrose Ludd, Anna Beyer, Andrew Bramble, Baptiste Cabarrou, Bart Vandewoestyne, Bertrand Dechoux, Brian Wong, Brooke Babcock, Charles Mims, Chris Earle, Chris Gilmore, Christian Burgas, Colin Goodheart-Smithe, Corey Wright, Daniel Wiesmann, David Pilato, Duncan Angus Wilkie, Florian Hopf, Gavin Foo, Gilbert Chang, Grégoire Seux, Gustavo Alberola, Igal Sapir, Iskren Ivov Chernev, Itamar Syn-Hershko, Jan Forrest, Jānis Peisenieks, Japheth Thomson, Jeff Myers, Jeff Patti, Jeremy Falling, Jeremy Nguyen, J.R. Heard, Joe Fleming, Jonathan Page, Joshua Gourneau, Josh Schneier, Jun Ohtani, Keiji Yoshida, Kieren Johnstone, Kim Laplume, Kurt Hurtado, Laszlo Balogh, londocr, losar, Lucian Precup, Lukáš Vlček, Malibu Carl, Margirier Laurent, Martijn Dwars, Matt Ruzicka, Mattias Pfeiffer, Mehdy Amazigh, mhemani, Michael Bonfils, Michael Bruns, Michael Salmon, Michael Scharf , Mitar Milutinović, Mustafa K. Isik, Nathan Peck, Patrick Peschlow, Paul Schwarz, Pieter Coucke, Raphaël Flores, Robert Muir, Ruslan Zavacky, Sanglarsh Boudhh, Santiago Gaviria, Scott Wilkerson, Sebastian Kurfürst, Sergii Golubev, Serkan Kucukbay, Thierry Jossermoz, Thomas Cucchietti, Tom Christie, Ulf Reimers, Venkat Somula, Wei Zhu, Will Kahn-Greene 和 Yuri Bakumenko。 感谢所有参与本书的中文译者与审校人员，他们牺牲了大量宝贵的休息时间，他们对翻译内容仔细斟酌，一丝不苟， 对修改意见认真对待，各抒己见，不厌其烦的进行修改与再次审校，这些默默奉献的可爱的人分别是： 薛杰，骆朗，彭秋源，魏喆，饶琛琳， 风虎，路小磊，michealzh，nodexy，sdlyjzh，落英流离， sunyonggang，Singham，烧碱，龙翔，陈思，陈华， 追风侃侃，Geolem，卷发，kfypmqqw，袁伟强，yichao， 小彬，leo，tangmisi，Alex，baifan，Evan，fanyer， wwb，瑞星，刘碧琴，walker，songgl， 吕兵，东，杜宁，秦东亮，biyuhao，刘刚， yumo，王秀文，zcola，gitqh，blackoon，David，韩炳辰， 韩陆，echolihao，Xargin，abel-sun，卞顺强， bsll，冬狼，王琦，Medcl。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-22 13:50:03 "},"2Introductory.html":{"url":"2Introductory.html","title":"基础入门","keywords":"","body":"基础入门你知道的, 为了搜索… 安装并运行Elasticsearch 安装Sense 和Elasticsearch交互 面向文档适应新环境索引雇员文档检索文档轻量搜索使用查询表达式搜索更复杂的搜索全文搜索短语搜索高亮搜索分析教程结语分布式特性后续步骤基础入门 Elasticsearch 是一个实时的分布式搜索分析引擎， 它能让你以一个之前从未有过的速度和规模，去探索你的数据。 它被用作全文检索、结构化搜索、分析以及这三个功能的组合： Wikipedia 使用 Elasticsearch 提供带有高亮片段的全文搜索，还有 search-as-you-type 和 did-you-mean 的建议。 卫报 使用 Elasticsearch 将网络社交数据结合到访客日志中，实时的给它的编辑们提供公众对于新文章的反馈。 Stack Overflow 将地理位置查询融入全文检索中去，并且使用 more-like-this 接口去查找相关的问题与答案。 GitHub 使用 Elasticsearch 对1300亿行代码进行查询。 然而 Elasticsearch 不仅仅为巨头公司服务。它也帮助了很多初创公司，像 Datadog 和 Klout， 帮助他们将想法用原型实现，并转化为可扩展的解决方案。Elasticsearch 能运行在你的笔记本电脑上，或者扩展到上百台服务器上去处理PB级数据。 Elasticsearch 中没有一个单独的组件是全新的或者是革命性的。全文搜索很久之前就已经可以做到了， 就像早就出现了的分析系统和分布式数据库。 革命性的成果在于将这些单独的，有用的组件融合到一个单一的、一致的、实时的应用中。它对于初学者而言有一个较低的门槛， 而当你的技能提升或需求增加时，它也始终能满足你的需求。 如果你现在打开这本书，是因为你拥有数据。除非你准备使用它 做些什么 ，否则拥有这些数据将没有意义。 不幸的是，大部分数据库在从你的数据中提取可用知识时出乎意料的低效。 当然，你可以通过时间戳或精确值进行过滤，但是它们能够进行全文检索、处理同义词、通过相关性给文档评分么？ 它们从同样的数据中生成分析与聚合数据吗？最重要的是，它们能实时地做到上面的那些而不经过大型批处理的任务么？ 这就是 Elasticsearch 脱颖而出的地方：Elasticsearch 鼓励你去探索与利用数据，而不是因为查询数据太困难，就让它们烂在数据仓库里面。 Elasticsearch 将成为你最好的朋友。 你知道的, 为了搜索… Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库--无论是开源还是私有。 但是 Lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。 更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理。Lucene 非常 复杂。 Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。 然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容： 一个分布式的实时文档存储，每个字段 可以被索引与搜索 一个分布式实时分析搜索引擎 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据 Elasticsearch 将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 RESTful API 进行通信， 可以使用自己喜欢的编程语言充当 web 客户端，甚至可以使用命令行（去充当这个客户端）。 就 Elasticsearch 而言，起步很简单。对于初学者来说，它预设了一些适当的默认值，并隐藏了复杂的搜索理论知识。 它 开箱即用 。只需最少的理解，你很快就能具有生产力。 随着你知识的积累，你可以利用 Elasticsearch 更多的高级特性，它的整个引擎是可配置并且灵活的。 从众多高级特性中，挑选恰当去修饰的 Elasticsearch，使它能解决你本地遇到的问题。 你可以免费下载，使用，修改 Elasticsearch。它在 Apache 2 license 协议下发布的， 这是众多灵活的开源协议之一。Elasticsearch 的源码被托管在 Github 上 github.com/elastic/elasticsearch。 如果你想加入我们这个令人惊奇的 contributors 社区，看这里 Contributing to Elasticsearch。 如果你对 Elasticsearch 有任何相关的问题，包括特定的特性(specific features)、语言客户端(language clients)、插件(plugins)，可以在这里 discuss.elastic.co 加入讨论。 回忆时光 许多年前，一个刚结婚的名叫 Shay Banon 的失业开发者，跟着他的妻子去了伦敦，他的妻子在那里学习厨师。 在寻找一个赚钱的工作的时候，为了给他的妻子做一个食谱搜索引擎，他开始使用 Lucene 的一个早期版本。 直接使用 Lucene 是很难的，因此 Shay 开始做一个抽象层，Java 开发者使用它可以很简单的给他们的程序添加搜索功能。 他发布了他的第一个开源项目 Compass。 后来 Shay 获得了一份工作，主要是高性能，分布式环境下的内存数据网格。这个对于高性能，实时，分布式搜索引擎的需求尤为突出， 他决定重写 Compass，把它变为一个独立的服务并取名 Elasticsearch。 第一个公开版本在2010年2月发布，从此以后，Elasticsearch 已经成为了 Github 上最活跃的项目之一，他拥有超过300名 contributors(目前736名 contributors )。 一家公司已经开始围绕 Elasticsearch 提供商业服务，并开发新的特性，但是，Elasticsearch 将永远开源并对所有人可用。 据说，Shay 的妻子还在等着她的食谱搜索引擎… 安装并运行Elasticsearch 想用最简单的方式去理解 Elasticsearch 能为你做什么，那就是使用它了，让我们开始吧！ 安装 Elasticsearch 之前，你需要先安装一个较新的版本的 Java，最好的选择是，你可以从 www.java.com 获得官方提供的最新版本的 Java。 之后，你可以从 elastic 的官网 elastic.co/downloads/elasticsearch 获取最新版本的 Elasticsearch。 要想安装 Elasticsearch，先下载并解压适合你操作系统的 Elasticsearch 版本。如果你想了解更多的信息， 可以查看 Elasticsearch 参考手册里边的安装部分，这边给出的链接指向安装说明 Installation。 当你准备在生产环境安装 Elasticsearch 时，你可以在 官网下载地址 找 到 Debian 或者 RPM 包，除此之外，你也可以使用官方支持的 Puppet module 或者 Chef cookbook。 当你解压好了归档文件之后，Elasticsearch 已经准备好运行了。按照下面的操作，在前台(foregroud)启动 Elasticsearch： cd elasticsearch- ./bin/elasticsearch 如果你想把 Elasticsearch 作为一个守护进程在后台运行，那么可以在后面添加参数 -d 。 如果你是在 Windows 上面运行 Elasticseach，你应该运行 bin\\elasticsearch.bat 而不是 bin\\elasticsearch 。 测试 Elasticsearch 是否启动成功，可以打开另一个终端，执行以下操作： curl 'http://localhost:9200/?pretty' TIP：如果你是在 Windows 上面运行 Elasticsearch，你可以从 http://curl.haxx.se/download.html 中下载 cURL。 cURL 给你提供了一种将请求提交到 Elasticsearch 的便捷方式，并且安装 cURL 之后，你可以通过复制与粘贴去尝试书中的许多例子。 你应该得到和下面类似的响应(response)： { \"name\" : \"Tom Foster\", \"cluster_name\" : \"elasticsearch\", \"version\" : { \"number\" : \"2.1.0\", \"build_hash\" : \"72cd1f1a3eee09505e036106146dc1949dc5dc87\", \"build_timestamp\" : \"2015-11-18T22:40:03Z\", \"build_snapshot\" : false, \"lucene_version\" : \"5.3.1\" }, \"tagline\" : \"You Know, for Search\" } 拷贝为 CURL在 SENSE 中查看 这就意味着你现在已经启动并运行一个 Elasticsearch 节点了，你可以用它做实验了。 单个 节点 可以作为一个运行中的 Elasticsearch 的实例。 而一个 集群 是一组拥有相同 cluster.name 的节点， 他们能一起工作并共享数据，还提供容错与可伸缩性。(当然，一个单独的节点也可以组成一个集群) 你可以在 elasticsearch.yml 配置文件中 修改 cluster.name ，该文件会在节点启动时加载 (译者注：这个重启服务后才会生效)。 关于上面的 cluster.name 以及其它 Important Configuration Changes 信息， 你可以在这本书后面提供的生产部署章节找到更多。 TIP：看到下方的 View in Sense 的例子了么？Install the Sense console 使用你自己的 Elasticsearch 集群去运行这本书中的例子， 查看会有怎样的结果。 当 Elastcisearch 在前台运行时，你可以通过按 Ctrl+C 去停止。 安装Sense Sense 是一个 Kibana 应用 它提供交互式的控制台，通过你的浏览器直接向 Elasticsearch 提交请求。 这本书的在线版本包含有一个 View in Sense 的链接，里面有许多代码示例。当点击的时候，它会打开一个代码示例的Sense控制台。 你不必安装 Sense，但是它允许你在本地的 Elasticsearch 集群上测试示例代码，从而使本书更具有交互性。 安装与运行 Sense： 在 Kibana 目录下运行下面的命令，下载并安装 Sense app： ./bin/kibana plugin --install elastic/sense Windows上面执行: bin\\kibana.bat plugin --install elastic/sense 。NOTE：你可以直接从这里 https://download.elastic.co/elastic/sense/sense-latest.tar.gz下载 Sense 离线安装可以查看这里 install it on an offline machine 。 启动 Kibana. ./bin/kibana Windows 上启动 kibana: bin\\kibana.bat 。 | 在你的浏览器中打开 Sense: http://localhost:5601/app/sense 。 和Elasticsearch交互 和 Elasticsearch 的交互方式取决于 你是否使用 Java Java API编辑 如果你正在使用 Java，在代码中你可以使用 Elasticsearch 内置的两个客户端： 节点客户端（Node client） 节点客户端作为一个非数据节点加入到本地集群中。换句话说，它本身不保存任何数据，但是它知道数据在集群中的哪个节点中，并且可以把请求转发到正确的节点。 传输客户端（Transport client） 轻量级的传输客户端可以将请求发送到远程集群。它本身不加入集群，但是它可以将请求转发到集群中的一个节点上。 两个 Java 客户端都是通过 9300 端口并使用 Elasticsearch 的原生 传输 协议和集群交互。集群中的节点通过端口 9300 彼此通信。如果这个端口没有打开，节点将无法形成一个集群。 Java 客户端作为节点必须和 Elasticsearch 有相同的 主要 版本；否则，它们之间将无法互相理解。 更多的 Java 客户端信息可以在 Elasticsearch Clients 中找到。 RESTful API with JSON over HTTP编辑 所有其他语言可以使用 RESTful API 通过端口 9200 和 Elasticsearch 进行通信，你可以用你最喜爱的 web 客户端访问 Elasticsearch 。事实上，正如你所看到的，你甚至可以使用 curl 命令来和 Elasticsearch 交互。 Elasticsearch 为以下语言提供了官方客户端 --Groovy、JavaScript、.NET、 PHP、 Perl、 Python 和 Ruby--还有很多社区提供的客户端和插件，所有这些都可以在 Elasticsearch Clients 中找到。 一个 Elasticsearch 请求和任何 HTTP 请求一样由若干相同的部件组成： curl -X '://:/?' -d '' 被 标记的部件： VERB 适当的 HTTP 方法 或 谓词 : GET、 POST、 PUT、 HEAD 或者 DELETE。 PROTOCOL http 或者 https（如果你在 Elasticsearch 前面有一个 https 代理） HOST Elasticsearch 集群中任意节点的主机名，或者用 localhost 代表本地机器上的节点。 PORT 运行 Elasticsearch HTTP 服务的端口号，默认是 9200 。 PATH API 的终端路径（例如 _count 将返回集群中文档数量）。Path 可能包含多个组件，例如：_cluster/stats 和 _nodes/stats/jvm 。 QUERY_STRING 任意可选的查询字符串参数 (例如 ?pretty 将格式化地输出 JSON 返回值，使其更容易阅读) BODY 一个 JSON 格式的请求体 (如果请求需要的话) 例如，计算集群中文档的数量，我们可以用这个: curl -XGET 'http://localhost:9200/_count?pretty' -d ' { \"query\": { \"match_all\": {} } } ' Elasticsearch 返回一个 HTTP 状态码（例如：200 OK）和（除HEAD请求）一个 JSON 格式的返回值。前面的 curl 请求将返回一个像下面一样的 JSON 体： { \"count\" : 0, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"failed\" : 0 } } 在返回结果中没有看到 HTTP 头信息是因为我们没有要求curl显示它们。想要看到头信息，需要结合 -i 参数来使用 curl 命令： curl -i -XGET 'localhost:9200/' 在书中剩余的部分，我们将用缩写格式来展示这些 curl 示例，所谓的缩写格式就是省略请求中所有相同的部分，例如主机名、端口号以及 curl 命令本身。而不是像下面显示的那样用一个完整的请求： curl -XGET 'localhost:9200/_count?pretty' -d ' { \"query\": { \"match_all\": {} } }' 我们将用缩写格式显示： GET /_count { \"query\": { \"match_all\": {} } } 拷贝为 CURL在 SENSE 中查看 事实上， Sense 控制台 也使用这样相同的格式。如果你正在阅读这本书的在线版本,可以通过点击 Sense 链接视图在 Sense 上打开和运行示例代码。 面向文档 在应用程序中对象很少只是一个简单的键和值的列表。通常，它们拥有更复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。 也许有一天你想把这些对象存储在数据库中。使用关系型数据库的行和列存储，这相当于是把一个表现力丰富的对象挤压到一个非常大的电子表格中：你必须将这个对象扁平化来适应表结构--通常一个字段>对应一列--而且又不得不在每次查询时重新构造对象。 Elasticsearch 是 面向文档 的，意味着它存储整个对象或 文档。Elasticsearch 不仅存储文档，而且 索引每个文档的内容使之可以被检索。在 Elasticsearch 中，你 对文档进行索引、检索、排序和过滤--而不是对行列数据。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因。 JSON编辑 Elasticsearch 使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式。JSON 序列化被大多数编程语言所支持，并且已经成为 NoSQL 领域的标准格式。 它简单、简洁、易于阅读。 考虑一下这个 JSON 文档，它代表了一个 user 对象： { \"email\": \"john@smith.com\", \"first_name\": \"John\", \"last_name\": \"Smith\", \"info\": { \"bio\": \"Eco-warrior and defender of the weak\", \"age\": 25, \"interests\": [ \"dolphins\", \"whales\" ] }, \"join_date\": \"2014/05/01\" } 虽然原始的 user 对象很复杂，但这个对象的结构和含义在 JSON 版本中都得到了体现和保留。在 Elasticsearch 中将对象转化为 JSON 并做索引要比在一个扁平的表结构中做相同的事情简单的多。 几乎所有的语言都有相应的模块可以将任意的数据结构或对象 转化成 JSON 格式，只是细节各不相同。具体请查看 serialization 或者 marshalling 这两个 处理 JSON 的模块。官方 Elasticsearch 客户端 自动为您提供 JSON 转化。 适应新环境 为了对 Elasticsearch 能实现什么及其上手容易程度有一个基本印象，让我们从一个简单的教程开始并介绍索引、搜索及聚合等基础概念。 我们将一并介绍一些新的技术术语和基础概念，因此即使无法立即全盘理解也无妨。在本书后续内容中，我们将深入介绍这里提到的所有概念。 接下来尽情享受 Elasticsearch 探索之旅。 创建一个雇员目录编辑 我们受雇于 Megacorp 公司，作为 HR 部门新的 “热爱无人机” （\"We love our drones!\"）激励项目的一部分，我们的任务是为此创建一个雇员目录。该目录应当能培养雇员认同感及支持实时、高效、动态协作，因此有一些业务需求： 支持包含多值标签、数值、以及全文本的数据 检索任一雇员的完整信息 允许结构化搜索，比如查询 30 岁以上的员工 允许简单的全文搜索以及较复杂的短语搜索 支持在匹配文档内容中高亮显示搜索片段 支持基于数据创建和管理分析仪表盘 索引雇员文档 第一个业务需求就是存储雇员数据。 这将会以 雇员文档 的形式存储：一个文档代表一个雇员。存储数据到 Elasticsearch 的行为叫做 索引 ，但在索引一个文档之前，需要确定将文档存储在哪里。 一个 Elasticsearch 集群可以 包含多个 索引 ，相应的每个索引可以包含多个 类型 。 这些不同的类型存储着多个 文档 ，每个文档又有 多个 属性 。 Index Versus Index Versus Index 你也许已经注意到 索引 这个词在 Elasticsearch 语境中包含多重意思， 所以有必要做一点儿说明： 索引（名词）： 如前所述，一个 索引 类似于传统关系数据库中的一个 数据库 ，是一个存储关系型文档的地方。 索引 (index) 的复数词为 indices 或 indexes 。 索引（动词）： 索引一个文档 就是存储一个文档到一个 索引 （名词）中以便它可以被检索和查询到。这非常类似于 SQL 语句中的 INSERT 关键词，除了文档已存在时新文档会替换旧文档情况之外。 倒排索引： 关系型数据库通过增加一个 索引 比如一个 B树（B-tree）索引 到指定的列上，以便提升数据检索速度。Elasticsearch 和 Lucene 使用了一个叫做 倒排索引 的结构来达到相同的目的。 + 默认的，一个文档中的每一个属性都是 被索引 的（有一个倒排索引）和可搜索的。一个没有倒排索引的属性是不能被搜索到的。我们将在 倒排索引 讨论倒排索引的更多细节。 对于雇员目录，我们将做如下操作： 每个雇员索引一个文档，包含该雇员的所有信息。 每个文档都将是 employee 类型 。 该类型位于 索引 megacorp 内。 该索引保存在我们的 Elasticsearch 集群中。 实践中这非常简单（尽管看起来有很多步骤），我们可以通过一条命令完成所有这些动作： PUT /megacorp/employee/1 { \"first_name\" : \"John\", \"last_name\" : \"Smith\", \"age\" : 25, \"about\" : \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] } 拷贝为 CURL在 SENSE 中查看 注意，路径 /megacorp/employee/1 包含了三部分的信息： megacorp 索引名称 employee 类型名称 1 特定雇员的ID 请求体 —— JSON 文档 —— 包含了这位员工的所有详细信息，他的名字叫 John Smith ，今年 25 岁，喜欢攀岩。 很简单！无需进行执行管理任务，如创建一个索引或指定每个属性的数据类型之类的，可以直接只索引一个文档。Elasticsearch 默认地完成其他一切，因此所有必需的管理任务都在后台使用默认设置完成。 进行下一步前，让我们增加更多的员工信息到目录中： PUT /megacorp/employee/2 { \"first_name\" : \"Jane\", \"last_name\" : \"Smith\", \"age\" : 32, \"about\" : \"I like to collect rock albums\", \"interests\": [ \"music\" ] } PUT /megacorp/employee/3 { \"first_name\" : \"Douglas\", \"last_name\" : \"Fir\", \"age\" : 35, \"about\": \"I like to build cabinets\", \"interests\": [ \"forestry\" ] } 检索文档 目前我们已经在 Elasticsearch 中存储了一些数据， 接下来就能专注于实现应用的业务需求了。第一个需求是可以检索到单个雇员的数据。 这在 Elasticsearch 中很简单。简单地执行 一个 HTTP GET 请求并指定文档的地址——索引库、类型和ID。 使用这三个信息可以返回原始的 JSON 文档： GET /megacorp/employee/1 拷贝为 CURL在 SENSE 中查看 返回结果包含了文档的一些元数据，以及 _source 属性，内容是 John Smith 雇员的原始 JSON 文档： { \"_index\" : \"megacorp\", \"_type\" : \"employee\", \"_id\" : \"1\", \"_version\" : 1, \"found\" : true, \"_source\" : { \"first_name\" : \"John\", \"last_name\" : \"Smith\", \"age\" : 25, \"about\" : \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] } } 将 HTTP 命令由 PUT 改为 GET 可以用来检索文档，同样的，可以使用 DELETE 命令来删除文档，以及使用 HEAD 指令来检查文档是否存在。如果想更新已存在的文档，只需再次 PUT。 轻量搜索 一个 GET 是相当简单的，可以直接得到指定的文档。 现在尝试点儿稍微高级的功能，比如一个简单的搜索！ 第一个尝试的几乎是最简单的搜索了。我们使用下列请求来搜索所有雇员： GET /megacorp/employee/_search 拷贝为 CURL在 SENSE 中查看 可以看到，我们仍然使用索引库 megacorp 以及类型 employee，但与指定一个文档 ID 不同，这次使用 _search 。返回结果包括了所有三个文档，放在数组 hits 中。一个搜索默认返回十条结果。 { \"took\": 6, \"timed_out\": false, \"_shards\": { ... }, \"hits\": { \"total\": 3, \"max_score\": 1, \"hits\": [ { \"_index\": \"megacorp\", \"_type\": \"employee\", \"_id\": \"3\", \"_score\": 1, \"_source\": { \"first_name\": \"Douglas\", \"last_name\": \"Fir\", \"age\": 35, \"about\": \"I like to build cabinets\", \"interests\": [ \"forestry\" ] } }, { \"_index\": \"megacorp\", \"_type\": \"employee\", \"_id\": \"1\", \"_score\": 1, \"_source\": { \"first_name\": \"John\", \"last_name\": \"Smith\", \"age\": 25, \"about\": \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] } }, { \"_index\": \"megacorp\", \"_type\": \"employee\", \"_id\": \"2\", \"_score\": 1, \"_source\": { \"first_name\": \"Jane\", \"last_name\": \"Smith\", \"age\": 32, \"about\": \"I like to collect rock albums\", \"interests\": [ \"music\" ] } } ] } } 注意：返回结果不仅告知匹配了哪些文档，还包含了整个文档本身：显示搜索结果给最终用户所需的全部信息。 接下来，尝试下搜索姓氏为 Smith 的雇员。为此，我们将使用一个 高亮 搜索，很容易通过命令行完成。这个方法一般涉及到一个 查询字符串 （query-string） 搜索，因为我们通过一个URL参数来传递查询信息给搜索接口： GET /megacorp/employee/_search?q=last_name:Smith 拷贝为 CURL在 SENSE 中查看 我们仍然在请求路径中使用 _search 端点，并将查询本身赋值给参数 q= 。返回结果给出了所有的 Smith： { ... \"hits\": { \"total\": 2, \"max_score\": 0.30685282, \"hits\": [ { ... \"_source\": { \"first_name\": \"John\", \"last_name\": \"Smith\", \"age\": 25, \"about\": \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] } }, { ... \"_source\": { \"first_name\": \"Jane\", \"last_name\": \"Smith\", \"age\": 32, \"about\": \"I like to collect rock albums\", \"interests\": [ \"music\" ] } } ] } } 使用查询表达式搜索 Query-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性（参见 轻量 搜索）。Elasticsearch 提供一个丰富灵活的查询语言叫做 查询表达式 ， 它支持构建更加复杂和健壮的查询。 领域特定语言 （DSL）， 指定了使用一个 JSON 请求。我们可以像这样重写之前的查询所有 Smith 的搜索 ： GET /megacorp/employee/_search { \"query\" : { \"match\" : { \"last_name\" : \"Smith\" } } } 拷贝为 CURL在 SENSE 中查看 返回结果与之前的查询一样，但还是可以看到有一些变化。其中之一是，不再使用 query-string 参数，而是一个请求体替代。这个请求使用 JSON 构造，并使用了一个 match 查询（属于查询类型之一，后续将会了解）。 更复杂的搜索 现在尝试下更复杂的搜索。 同样搜索姓氏为 Smith 的雇员，但这次我们只需要年龄大于 30 的。查询需要稍作调整，使用过滤器 filter ，它支持高效地执行一个结构化查询。 GET /megacorp/employee/_search { \"query\" : { \"bool\": { \"must\": { \"match\" : { \"last_name\" : \"smith\" } }, \"filter\": { \"range\" : { \"age\" : { \"gt\" : 30 } } } } } } 拷贝为 CURL在 SENSE 中查看 这部分与我们之前使用的 match 查询 一样。 这部分是一个 range 过滤器 ， 它能找到年龄大于 30 的文档，其中 gt 表示_大于(_great than)。 目前无需太多担心语法问题，后续会更详细地介绍。只需明确我们添加了一个 过滤器 用于执行一个范围查询，并复用之前的 match 查询。现在结果只返回了一个雇员，叫 Jane Smith，32 岁。 { ... \"hits\": { \"total\": 1, \"max_score\": 0.30685282, \"hits\": [ { ... \"_source\": { \"first_name\": \"Jane\", \"last_name\": \"Smith\", \"age\": 32, \"about\": \"I like to collect rock albums\", \"interests\": [ \"music\" ] } } ] } } 全文搜索 截止目前的搜索相对都很简单：单个姓名，通过年龄过滤。现在尝试下稍微高级点儿的全文搜索——一项传统数据库确实很难搞定的任务。 搜索下所有喜欢攀岩（rock climbing）的雇员： GET /megacorp/employee/_search { \"query\" : { \"match\" : { \"about\" : \"rock climbing\" } } } 拷贝为 CURL在 SENSE 中查看 显然我们依旧使用之前的 match 查询在about 属性上搜索 “rock climbing” 。得到两个匹配的文档： { ... \"hits\": { \"total\": 2, \"max_score\": 0.16273327, \"hits\": [ { ... \"_score\": 0.16273327, \"_source\": { \"first_name\": \"John\", \"last_name\": \"Smith\", \"age\": 25, \"about\": \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] } }, { ... \"_score\": 0.016878016, \"_source\": { \"first_name\": \"Jane\", \"last_name\": \"Smith\", \"age\": 32, \"about\": \"I like to collect rock albums\", \"interests\": [ \"music\" ] } } ] } } 相关性得分 Elasticsearch 默认按照相关性得分排序，即每个文档跟查询的匹配程度。第一个最高得分的结果很明显：John Smith 的 about 属性清楚地写着 “rock climbing” 。 但为什么 Jane Smith 也作为结果返回了呢？原因是她的 about 属性里提到了 “rock” 。因为只有 “rock” 而没有 “climbing” ，所以她的相关性得分低于 John 的。 这是一个很好的案例，阐明了 Elasticsearch 如何 在 全文属性上搜索并返回相关性最强的结果。Elasticsearch中的 相关性 概念非常重要，也是完全区别于传统关系型数据库的一个概念，数据库中的一条记录要么匹配要么不匹配。 短语搜索 找出一个属性中的独立单词是没有问题的，但有时候想要精确匹配一系列单词或者短语 。 比如， 我们想执行这样一个查询，仅匹配同时包含 “rock” 和 “climbing” ，并且 二者以短语 “rock climbing” 的形式紧挨着的雇员记录。 为此对 match 查询稍作调整，使用一个叫做 match_phrase 的查询： GET /megacorp/employee/_search { \"query\" : { \"match_phrase\" : { \"about\" : \"rock climbing\" } } } 拷贝为 CURL在 SENSE 中查看 毫无悬念，返回结果仅有 John Smith 的文档。 { ... \"hits\": { \"total\": 1, \"max_score\": 0.23013961, \"hits\": [ { ... \"_score\": 0.23013961, \"_source\": { \"first_name\": \"John\", \"last_name\": \"Smith\", \"age\": 25, \"about\": \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] } } ] } } 高亮搜索 许多应用都倾向于在每个搜索结果中 高亮 部分文本片段，以便让用户知道为何该文档符合查询条件。在 Elasticsearch 中检索出高亮片段也很容易。 再次执行前面的查询，并增加一个新的 highlight 参数： GET /megacorp/employee/_search { \"query\" : { \"match_phrase\" : { \"about\" : \"rock climbing\" } }, \"highlight\": { \"fields\" : { \"about\" : {} } } } 拷贝为 CURL在 SENSE 中查看 当执行该查询时，返回结果与之前一样，与此同时结果中还多了一个叫做 highlight 的部分。这个部分包含了 about 属性匹配的文本片段，并以 HTML 标签 封装： { ... \"hits\": { \"total\": 1, \"max_score\": 0.23013961, \"hits\": [ { ... \"_score\": 0.23013961, \"_source\": { \"first_name\": \"John\", \"last_name\": \"Smith\", \"age\": 25, \"about\": \"I love to go rock climbing\", \"interests\": [ \"sports\", \"music\" ] }, \"highlight\": { \"about\": [ \"I love to go rock climbing\" ] } } ] } } 原始文本中的高亮片段 关于高亮搜索片段，可以在 highlighting reference documentation 了解更多信息。 分析 终于到了最后一个业务需求：支持管理者对雇员目录做分析。 Elasticsearch 有一个功能叫聚合（aggregations），允许我们基于数据生成一些精细的分析结果。聚合与 SQL 中的 GROUP BY 类似但更强大。 举个例子，挖掘出雇员中最受欢迎的兴趣爱好： GET /megacorp/employee/_search { \"aggs\": { \"all_interests\": { \"terms\": { \"field\": \"interests\" } } } } 拷贝为 CURL在 SENSE 中查看 暂时忽略掉语法，直接看看结果： { ... \"hits\": { ... }, \"aggregations\": { \"all_interests\": { \"buckets\": [ { \"key\": \"music\", \"doc_count\": 2 }, { \"key\": \"forestry\", \"doc_count\": 1 }, { \"key\": \"sports\", \"doc_count\": 1 } ] } } } 可以看到，两位员工对音乐感兴趣，一位对林地感兴趣，一位对运动感兴趣。这些聚合并非预先统计，而是从匹配当前查询的文档中即时生成。如果想知道叫 Smith 的雇员中最受欢迎的兴趣爱好，可以直接添加适当的查询来组合查询： GET /megacorp/employee/_search { \"query\": { \"match\": { \"last_name\": \"smith\" } }, \"aggs\": { \"all_interests\": { \"terms\": { \"field\": \"interests\" } } } } 拷贝为 CURL在 SENSE 中查看 all_interests 聚合已经变为只包含匹配查询的文档： ... \"all_interests\": { \"buckets\": [ { \"key\": \"music\", \"doc_count\": 2 }, { \"key\": \"sports\", \"doc_count\": 1 } ] } 聚合还支持分级汇总 。比如，查询特定兴趣爱好员工的平均年龄： GET /megacorp/employee/_search { \"aggs\" : { \"all_interests\" : { \"terms\" : { \"field\" : \"interests\" }, \"aggs\" : { \"avg_age\" : { \"avg\" : { \"field\" : \"age\" } } } } } } 拷贝为 CURL在 SENSE 中查看 得到的聚合结果有点儿复杂，但理解起来还是很简单的： ... \"all_interests\": { \"buckets\": [ { \"key\": \"music\", \"doc_count\": 2, \"avg_age\": { \"value\": 28.5 } }, { \"key\": \"forestry\", \"doc_count\": 1, \"avg_age\": { \"value\": 35 } }, { \"key\": \"sports\", \"doc_count\": 1, \"avg_age\": { \"value\": 25 } } ] } 输出基本是第一次聚合的加强版。依然有一个兴趣及数量的列表，只不过每个兴趣都有了一个附加的 avg_age 属性，代表有这个兴趣爱好的所有员工的平均年龄。 即使现在不太理解这些语法也没有关系，依然很容易了解到复杂聚合及分组通过 Elasticsearch 特性实现得很完美。可提取的数据类型毫无限制。 教程结语 欣喜的是，这是一个关于 Elasticsearch 基础描述的教程，且仅仅是浅尝辄止，更多诸如 suggestions、geolocation、percolation、fuzzy 与 partial matching 等特性均被省略，以便保持教程的简洁。但它确实突显了开始构建高级搜索功能多么容易。不需要配置——只需要添加数据并开始搜索！ 很可能语法会让你在某些地方有所困惑，并且对各个方面如何微调也有一些问题。没关系！本书后续内容将针对每个问题详细解释，让你全方位地理解 Elasticsearch 的工作原理。 分布式特性 在本章开头，我们提到过 Elasticsearch 可以横向扩展至数百（甚至数千）的服务器节点，同时可以处理PB级数据。我们的教程给出了一些使用 Elasticsearch 的示例，但并不涉及任何内部机制。Elasticsearch 天生就是分布式的，并且在设计时屏蔽了分布式的复杂性。 Elasticsearch 在分布式方面几乎是透明的。教程中并不要求了解分布式系统、分片、集群发现或其他的各种分布式概念。可以使用笔记本上的单节点轻松地运行教程里的程序，但如果你想要在 100 个节点的集群上运行程序，一切依然顺畅。 Elasticsearch 尽可能地屏蔽了分布式系统的复杂性。这里列举了一些在后台自动执行的操作： 分配文档到不同的容器 或 分片 中，文档可以储存在一个或多个节点中 按集群节点来均衡分配这些分片，从而对索引和搜索过程进行负载均衡 复制每个分片以支持数据冗余，从而防止硬件故障导致的数据丢失 将集群中任一节点的请求路由到存有相关数据的节点 集群扩容时无缝整合新节点，重新分配分片以便从离群节点恢复 当阅读本书时，将会遇到有关 Elasticsearch 分布式特性的补充章节。这些章节将介绍有关集群扩容、故障转移(集群内的原理) 、应对文档存储(分布式文档存储) 、执行分布式搜索(执行分布式检索) ，以及分区（shard）及其工作原理(分片内部原理) 。 这些章节并非必读，完全可以无需了解内部机制就使用 Elasticsearch，但是它们将从另一个角度帮助你了解更完整的 Elasticsearch 知识。可以根据需要跳过它们，或者想更完整地理解时再回头阅读也无妨。 后续步骤 现在对于通过 Elasticsearch 能够实现什么样的功能、以及上手的简易程度应该有了初步概念。Elasticsearch 力图通过最少的知识和配置做到开箱即用。学习 Elasticsearch 的最好方式是投入实践：尽管开始索引和搜索吧！ 然而，对于 Elasticsearch 知道得越多，就越有生产效率。告诉 Elasticsearch 越多的领域知识，就越容易进行结果调优。 本书的后续内容将帮助你从新手成长为专家，每个章节不仅阐述必要的基础知识，而且包含专家建议。如果刚刚上手，这些建议可能无法立竿见影；但 Elasticsearch 有着合理的默认设置，在无需干预的情况下通常都能工作得很好。当追求毫秒级的性能提升时，随时可以重温这些章节。 Copyright © WS 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-02-22 13:57:20 "}}